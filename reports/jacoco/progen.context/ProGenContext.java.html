<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ProGenContext.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ProGen</a> &gt; <a href="index.source.html" class="el_package">progen.context</a> &gt; <span class="el_source">ProGenContext.java</span></div><h1>ProGenContext.java</h1><pre class="source lang-java linenums">package progen.context;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

/**
 * Clase que unifica la recuperación de las distintas propiedades definidas en
 * los ficheros de configuración.
 * &lt;p/&gt;
 * Provee de métodos para recuperar propiedades obligatorias, optativas,
 * porcentajes, etc.
 * 
 * @author jirsis
 */
public class ProGenContext {
  /**
   * Cadena que se utiliza para subopciones en distintos parámetros.
   */
  private final static String parametersDelim = &quot;\\(&quot;;
  /**
   * Almacénd de propiedades que es implementado por un Singleton de tal forma
   * que únicamente exista una instancia en toda la ejecución.
   */
  private static ProGenContext proGenProps;
  /**
   * Estructura de datos que almacenta todas las propiedades disponibles en el
   * dominio del problema
   */
  private Properties properties;

  /**
   * Constructor privado del Singleton
   */
<span class="fc" id="L44">  private ProGenContext() {</span>
<span class="fc" id="L45">    properties = new Properties();</span>
<span class="fc" id="L46">  }</span>

  /**
   * Define la única forma que existe de instanciar e inicializar este
   * componente, a partir del fichero &lt;i&gt;master&lt;/i&gt; del dominio de la
   * aplicación.
   * 
   * @param file
   *          Fichero maestro de donde se cargarán los distintos valores de
   *          configuración.
   * @return La instancia desde la que se podrán recuperar las opciones
   *         definidas.
   * @throws MissingContextFileException
   *           En caso de que no se encuentre el fichero maestro de
   *           configuración. múltiples veces.
   * @throws IOException
   */
  public static ProGenContext makeInstance(String file) throws MissingContextFileException {

<span class="fc bfc" id="L65" title="All 2 branches covered.">    if (file == null) {</span>
<span class="fc" id="L66">      throw new MissingContextFileException();</span>
    } else {

      try {
<span class="fc" id="L70">        InputStream fis = getResource(file);</span>

<span class="fc" id="L72">        proGenProps = new ProGenContext();</span>
<span class="fc" id="L73">        proGenProps.loadOtherPropertiesFile(&quot;ProGen.conf&quot;);</span>

<span class="fc" id="L75">        proGenProps.properties.load(fis);</span>
<span class="fc" id="L76">        ProGenContext.setProperty(&quot;progen.masterfile&quot;, new File(file).getAbsolutePath());</span>
<span class="fc" id="L77">        fis.close();</span>
<span class="fc" id="L78">      } catch (NullPointerException e) {</span>
<span class="fc" id="L79">        throw new MissingContextFileException(e.getMessage());</span>
<span class="nc" id="L80">      } catch (IOException e) {</span>
<span class="nc" id="L81">        throw new MissingContextFileException(e.getMessage());</span>
<span class="fc" id="L82">      }</span>
    }
<span class="fc" id="L84">    return proGenProps;</span>
  }

  private static InputStream getResource(String file) {
<span class="fc" id="L88">    return ProGenContext.class.getClassLoader().getResourceAsStream(file);</span>
  }

  /**
   * Devuelve la única instancia que existe de las propiedades. En caso de no
   * existir, crea las propiedades vacías y lo devuelve tal cual.
   * 
   * @return La referencia a la única instancia de propiedades de ProGen
   */
  public synchronized static ProGenContext makeInstance() {
<span class="fc bfc" id="L98" title="All 2 branches covered.">    if (proGenProps == null) {</span>
<span class="fc" id="L99">      proGenProps = new ProGenContext();</span>
    }
<span class="fc" id="L101">    return proGenProps;</span>
  }

  /**
   * Forma de obtener el valor de la propiedad identificada por parámetro. Al
   * tener caracter opcional, en caso de no estar definida, se devolverá el
   * valor pasado como segundo parámetro.
   * 
   * @param property
   *          identificador de la propiedad.
   * @param defaultValue
   *          valor por defecto
   * @return valor de la propiedad solicitada recuperada desde los ficheros de
   *         configuración o valor por defecto en caso de no estar definida.
   */
  public static int getOptionalProperty(String property, int defaultValue) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">    if (ProGenContext.getProperty(property) == null) {</span>
<span class="fc" id="L118">      return defaultValue;</span>
    } else {
<span class="fc" id="L120">      return Integer.parseInt(ProGenContext.getProperty(property).split(parametersDelim)[0]);</span>
    }
  }

  /**
   * Forma de obtener el valor de la propiedad identificada por parámetro. Al
   * tener caracter opcional, en caso de no estar definida, se devolverá el
   * valor pasado como segundo parámetro.
   * 
   * @param property
   *          identificador de la propiedad.
   * @param defaultValue
   *          valor por defecto
   * @return valor de la propiedad solicitada recuperada desde los ficheros de
   *         configuración o valor por defecto en caso de no estar definida.
   */
  public static String getOptionalProperty(String property, String defaultValue) {
    String value;
<span class="fc bfc" id="L138" title="All 2 branches covered.">    if (ProGenContext.getProperty(property) == null) {</span>
<span class="fc" id="L139">      value = defaultValue;</span>
    } else {
<span class="fc" id="L141">      value = ProGenContext.getProperty(property).split(parametersDelim)[0];</span>
    }
<span class="fc" id="L143">    return value;</span>
  }

  /**
   * Forma de obtener el valor de la propiedad identificada por parámetro. Al
   * tener caracter opcional, en caso de no estar definida, se devolverá el
   * valor pasado como segundo parámetro.
   * 
   * @param property
   *          identificador de la propiedad.
   * @param defaultValue
   *          valor por defecto
   * @return valor de la propiedad solicitada recuperada desde los ficheros de
   *         configuración o valor por defecto en caso de no estar definida.
   */
  public static double getOptionalProperty(String property, double defaultValue) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">    if (ProGenContext.getProperty(property) == null) {</span>
<span class="fc" id="L160">      return defaultValue;</span>
    } else {
<span class="fc" id="L162">      return Double.parseDouble(ProGenContext.getProperty(property).split(parametersDelim)[0]);</span>
    }
  }

  /**
   * Forma de obtener el valor de la propiedad identificada por parámetro. Al
   * tener caracter opcional, en caso de no estar definida, se devolverá el
   * valor pasado como segundo parámetro.
   * 
   * @param property
   *          identificador de la propiedad.
   * @param defaultValue
   *          valor por defecto
   * @return valor de la propiedad solicitada recuperada desde los ficheros de
   *         configuración o valor por defecto en caso de no estar definida.
   */
  public static boolean getOptionalProperty(String property, boolean defaultValue) {
<span class="fc bfc" id="L179" title="All 2 branches covered.">    if (ProGenContext.getProperty(property) == null) {</span>
<span class="fc" id="L180">      return defaultValue;</span>
    } else {
<span class="fc" id="L182">      return Boolean.parseBoolean(ProGenContext.getProperty(property).split(parametersDelim)[0]);</span>
    }
  }

  /**
   * Forma de obtener el valor de una propiedad definida en los ficheros de
   * configuración, identificada por el parámetro definido. Será responsabilidad
   * de la parte que realiza esta llamada, comprobar si el contenido de esta
   * propiedad es correcto y acorde a lo que se espera.
   * 
   * @param key
   *          Identificador de la propiedad a recuperar
   * @return &lt;code&gt;String&lt;/code&gt; con el valor de la propiedad tal y como aparece
   *         en el fichero de configuración.
   */
  public static String getMandatoryProperty(String key) {
<span class="fc" id="L198">    String property = getProperty(key);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    if (property == null)</span>
<span class="fc" id="L200">      throw new UndefinedMandatoryPropertyException(key);</span>
<span class="fc" id="L201">    return property.split(parametersDelim)[0];</span>
  }

  /**
   * Metodo de acceso para recuperar cualquier propiedad definida, identificada
   * por el parámetro
   * 
   * @param key
   *          Identificador de la propiedad a recuperar
   * @return valor de la propiedad recuperada
   * @see #makeInstance(String)
   */
  private static String getProperty(String key) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (proGenProps == null) {</span>
<span class="fc" id="L215">      throw new UninitializedContextException();</span>
    }
<span class="fc" id="L217">    return proGenProps.properties.getProperty(key);</span>
  }

  /**
   * Devuelve el valor del porcentaje de uso de una subopción definida en el
   * contexto del dominio. Para ello, es necesario definir la subopción
   * separándola de la opción con dos puntos (:) y el porcentaje definido como
   * tanto por ciento o como un valor entre 0 y 1. A su vez, las distintas
   * subopciones, tienen que ir separadas por comas (,).
   * 
   * @param key
   *          La opción a recuperar.
   * @param subOption
   *          La subopción a recuperar dentro de la opción.
   * @param defaultPercent
   *          El porcentaje por defecto, en caso de que no exista esta
   *          subopción.
   * @return Devuelve un valor entre 0 y 1, que representa dicho porcentaje.
   */
  public static double getSuboptionPercent(String key, String subOption, double defaultPercent) {
<span class="fc" id="L237">    double value = defaultPercent;</span>
<span class="fc" id="L238">    String suboption = getParameter(key, subOption);</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (suboption != null) {</span>
<span class="fc" id="L241">      value = getPercent(suboption);</span>
    }

<span class="fc" id="L244">    return value;</span>
  }

  /**
   * Recupera un porcentaje definido en una opción, de tal forma que esta opción
   * no es obligatoria que se defina.
   * 
   * @param key
   *          La propiedad a recuperar.
   * @param defaultPercent
   *          El valor por defecto en caso de no haberse definido la propiedad.
   * @return Un valor entre 0 y 1, que representa dicho porcentaje.
   */
  public static double getOptionalPercent(String key, String defaultPercent) {
<span class="fc" id="L258">    defaultPercent = getOptionalProperty(key, defaultPercent);</span>
<span class="fc" id="L259">    return getPercent(defaultPercent);</span>
  }

  /**
   * Recupera un porcentaje definido en una opción de forma obligatoria.
   * 
   * @param key
   *          La propiedad a recuperar.
   * @return Un valor entre 0 y 1, que representa dicho porcentaje.
   */
  public static double getMandatoryPercent(String key) {
<span class="fc" id="L270">    String property = getProperty(key);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">    if (property == null)</span>
<span class="fc" id="L272">      throw new UndefinedMandatoryPropertyException(key);</span>
<span class="fc" id="L273">    return getPercent(property);</span>
  }

  /**
   * Recupera una colección con todas las opciones que coinciden comparten una
   * parte del nombre, definido en el parámetro.
   * 
   * @param family
   *          La parte común del nombre de la propiedad.
   * @return Una colección con todas las propiedades que cumplen con el
   *         criterio.
   */
  public static List&lt;String&gt; getFamilyOptions(String family) {
<span class="fc" id="L286">    List&lt;String&gt; options = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L287">    Iterator&lt;Object&gt; i = proGenProps.properties.keySet().iterator();</span>
    String option;
<span class="fc bfc" id="L289" title="All 2 branches covered.">    while (i.hasNext()) {</span>
<span class="fc" id="L290">      option = (String) i.next();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">      if (option.indexOf(family) == 0) {</span>
<span class="fc" id="L292">        options.add(option);</span>
      }
    }
<span class="fc" id="L295">    return options;</span>
  }

  /**
   * Recupera el valor numérico de un tanto por ciento, representado en una
   * cadena como valor entre 0 y 1 o con un valor entre 0 y 100 y acabado con el
   * símbolo por ciento (%).
   * 
   * @param percent
   *          La cadena a convertir en valor numérico.
   * @return Un número comprendido entre 0 y 1.
   */
  private static double getPercent(String percent) {
<span class="fc" id="L308">    double value = 0.0;</span>
<span class="fc" id="L309">    percent = percent.replaceAll(&quot; &quot;, &quot;&quot;);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">    if (percent.endsWith(&quot;%&quot;)) {</span>
<span class="fc" id="L311">      value = Double.parseDouble(percent.substring(0, percent.length() - 1)) / 100;</span>
    } else {
<span class="fc" id="L313">      value = Double.parseDouble(percent);</span>
    }
<span class="fc" id="L315">    return value;</span>
  }

  /**
   * Añade una propiedad al conjunto de propiedades definidas en ProGen.
   * 
   * @param key
   *          Identificador de la propiedad.
   * @param value
   *          Valor concreto que tomará la propiedad.
   */
  public static void setProperty(String key, String value) {
<span class="fc" id="L327">    proGenProps.properties.setProperty(key, value);</span>
<span class="fc" id="L328">    proGenProps.calculateProperties();</span>
<span class="fc" id="L329">  }</span>

  /**
   * Elimina todas las propiedades que estuvieran definidas en el contexto.
   */
  public static void clearContext() {
<span class="fc" id="L335">    proGenProps = null;</span>
<span class="fc" id="L336">  }</span>

  /**
   * Devuelve el valor concreto de un parámetro de configuración de una opción.
   * En caso de que no exista la opción o la subopción de la que se quiere
   * obtener el valor, se devolverá el valor null; y en caso de que haya algún
   * parámetro no definido según la forma indicada a continuación, se lanzará
   * una {@link MalformedParameterException} indicando la pareja
   * opción-subopción que se no cumple con el formato. El formato específico
   * para definir los parámetros es: &lt;code&gt;
   * progen.opcion=valor(subopcion1=valor1, subopcion2=valor2, ...)&lt;br/&gt;
   * &lt;/code&gt;
   * 
   * @param option
   *          Opción de la que se obtendrá un parámetro.
   * @param parameter
   *          Parámetro de la que se quiere obtener un valor concreto.
   * @return El valor del parámetro o null en caso de no encontrarse.
   */
  public static String getParameter(String option, String parameter) {
<span class="fc" id="L356">    String value = null;</span>
<span class="fc" id="L357">    value = getParameters(option).get(parameter);</span>
<span class="fc" id="L358">    return value;</span>
  }

  /**
   * Devuelve todos los parámetros asociados a una opción determinada. En caso
   * de no estar definida la opción o que no tenga parámetros extra, se
   * devolverá un Map vacío, es decir, de tamaño 0.
   * 
   * @param option
   *          La opción para recuperar los parámetros.
   * @return La colección de parámetros asociados a dicha opción.
   */
  public static Map&lt;String, String&gt; getParameters(String option) {
<span class="fc" id="L371">    Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;();</span>
    String parametersContext;
<span class="fc" id="L373">    parametersContext = getProperty(option);</span>

    // Se controla que exista la opción y tenga al menos un parámetro.
<span class="fc bfc" id="L376" title="All 4 branches covered.">    if (parametersContext != null &amp;&amp; parametersContext.split(parametersDelim).length &gt; 1) {</span>
<span class="fc" id="L377">      parametersContext = parametersContext.split(parametersDelim)[1];</span>
      // se recupera el valor y se elimina el el posible ) del final
<span class="fc" id="L379">      parametersContext = parametersContext.replace(&quot;)&quot;, &quot;&quot;);</span>
<span class="fc" id="L380">      String parameterKey = null, parameterValue = null;</span>
      try {
        // se separan todos los parámetros
<span class="fc" id="L383">        String[] parametersValues = parametersContext.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (String parameter : parametersValues) {</span>
<span class="fc" id="L385">          parameterKey = parameter.split(&quot;=&quot;)[0].trim();</span>
<span class="fc" id="L386">          parameterValue = parameter.split(&quot;=&quot;)[1].trim();</span>
<span class="fc" id="L387">          parameters.put(parameterKey, parameterValue);</span>
        }
<span class="fc" id="L389">      } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="fc" id="L390">        throw new MalformedParameterException(option + &quot;,&quot; + parameterKey);</span>
<span class="fc" id="L391">      }</span>
    }
<span class="fc" id="L393">    return parameters;</span>
  }

  public static void loadExtraConfiguration() {
    try {
<span class="fc" id="L398">      proGenProps.calculateProperties();</span>
<span class="fc" id="L399">      proGenProps.loadOtherProperties();</span>
<span class="nc" id="L400">    } catch (FileNotFoundException fnfe) {</span>
<span class="nc" id="L401">      throw new MissingContextFileException(fnfe.getMessage());</span>
<span class="nc" id="L402">    } catch (IOException ioe) {</span>
<span class="nc" id="L403">      throw new MissingContextFileException(ioe.getMessage());</span>
<span class="fc" id="L404">    }</span>

<span class="fc" id="L406">  }</span>

  /**
   * Carga las opciones definidas en otros ficheros a parte del fichero maestro.
   * Carga también las definidas en el fichero especificado en la propiedad
   * &lt;code&gt;progen.experiment-file&lt;/code&gt; en el fichero maestro y las que están
   * definidas en los ficheros del dominio de especificación de experimentos (
   * &lt;code&gt;-experiment&lt;/code&gt;) y hypergp (&lt;code&gt;-hypergp&lt;/code&gt; ).
   * 
   * @throws FileNotFoundException
   *           Si el fichero del dominio no existe.
   * @throws IOException
   *           Si ocurre un error de E/S.
   */
  private void loadOtherProperties() throws FileNotFoundException, IOException {
<span class="fc" id="L421">    loadOtherProperties(&quot;progen.experiment.file&quot;);</span>
<span class="fc" id="L422">    loadOptionalFile(&quot;-experimenter&quot;);</span>
<span class="fc" id="L423">    loadOptionalFile(&quot;-hypergp&quot;);</span>

<span class="fc" id="L425">  }</span>

  /**
   * Carga directamente un fichero de propiedades al conjunto de las que ya
   * estén definidas en ProGen. Primero buscará en el directorio raíz del
   * proyecto y en caso de no encontrarlo, buscará en el directorio
   * &lt;code&gt;home&lt;/code&gt; del experimento.
   * 
   * @param propertyFile
   *          El nombre del fichero de propiedades.
   * @throws IOException
   */
  private void loadOtherPropertiesFile(String propertyFile) throws IOException {
    Properties otherProperties;
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">    if (propertyFile != null) {</span>
<span class="fc" id="L440">      otherProperties = new Properties();</span>
      try {
<span class="fc" id="L442">        findPropertiesAbsolutePath(propertyFile, otherProperties);</span>
<span class="nc" id="L443">      } catch (FileNotFoundException fnfe) {</span>
<span class="nc" id="L444">        findPropertiesUserProjectPath(propertyFile, otherProperties);</span>
<span class="fc" id="L445">      }</span>
<span class="fc" id="L446">      chekProperties(otherProperties);</span>
    }
<span class="fc" id="L448">  }</span>

  private void chekProperties(Properties otherProperties) {
    Enumeration&lt;Object&gt; keys;
    String key;
    String value;
<span class="fc" id="L454">    keys = otherProperties.keys();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">    while (keys.hasMoreElements()) {</span>
<span class="fc" id="L456">      key = (String) keys.nextElement();</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">      if (proGenProps.properties.containsKey(key)) {</span>
<span class="nc" id="L458">        throw new DuplicatedPropertyException(key);</span>
      } else {
<span class="fc" id="L460">        value = otherProperties.getProperty(key);</span>
<span class="fc" id="L461">        proGenProps.properties.put(key, value);</span>
      }
    }
<span class="fc" id="L464">  }</span>

  private void findPropertiesUserProjectPath(String propertyFile, Properties otherProperties) throws IOException {
<span class="nc" id="L467">    propertyFile = proGenProps.properties.getProperty(&quot;progen.user.home&quot;).replace('.', File.separatorChar) + propertyFile;</span>
<span class="nc" id="L468">    findPropertiesAbsolutePath(propertyFile, otherProperties);</span>
<span class="nc" id="L469">  }</span>

  private void findPropertiesAbsolutePath(String propertyFile, Properties otherProperties) throws IOException {
<span class="fc" id="L472">    InputStream fis = getResource(propertyFile);</span>
<span class="fc" id="L473">    otherProperties.load(fis);</span>
<span class="fc" id="L474">    fis.close();</span>
<span class="fc" id="L475">  }</span>

  /**
   * Carga algún fichero de configuración especéfica del dominio del problema.
   * 
   * @param propertyFile
   *          el fichero a cargar.
   * @throws FileNotFoundException
   *           Si no existe el fichero.
   * @throws IOException
   *           Si ocurre un error de E/S.
   */
  private void loadOtherProperties(String propertyFile) throws FileNotFoundException, IOException {
    Properties otherProperties;
<span class="fc" id="L489">    String otherFile = proGenProps.properties.getProperty(propertyFile);</span>

<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    if (otherFile != null) {</span>
<span class="fc" id="L492">      otherFile = convertClasspath2Path(otherFile);</span>
<span class="fc" id="L493">      otherProperties = new Properties();</span>
      try {
<span class="fc" id="L495">        lookForInAbsolutePath(otherProperties, otherFile);        </span>
<span class="nc" id="L496">      } catch (FileNotFoundException fnfe) {</span>
<span class="nc" id="L497">        lookForInUserProject(propertyFile, otherProperties);</span>
<span class="fc" id="L498">      }</span>
<span class="fc" id="L499">      chekProperties(otherProperties);</span>
    }
<span class="fc" id="L501">  }</span>
  
  private void lookForInAbsolutePath(Properties otherProperties, String otherFile) throws IOException {
    InputStream inputStream;
<span class="fc" id="L505">    inputStream = getResource(otherFile);</span>
    try {
<span class="fc" id="L507">      otherProperties.load(inputStream );</span>
    } finally{
<span class="pc bpc" id="L509" title="3 of 4 branches missed.">      if(inputStream != null){</span>
<span class="pc" id="L510">        inputStream.close();</span>
      }
    }
<span class="fc" id="L513">  }</span>
  
  private FileInputStream lookForInUserProject(String propertyFile, Properties otherProperties) throws IOException {
<span class="nc" id="L516">    FileInputStream fileInputStream = null;</span>
<span class="nc" id="L517">    String otherFile = proGenProps.getProperty(&quot;progen.user.home&quot;).replace('.', File.separatorChar) + proGenProps.properties.getProperty(propertyFile);</span>
    try {
<span class="nc" id="L519">      fileInputStream = new FileInputStream(otherFile);</span>
<span class="nc" id="L520">      otherProperties.load(fileInputStream);</span>
    } finally{
<span class="nc bnc" id="L522" title="All 4 branches missed.">      if(fileInputStream != null){</span>
<span class="nc" id="L523">        fileInputStream.close();</span>
      }
    }
    
<span class="nc" id="L527">    return fileInputStream;</span>
  }

  private String convertClasspath2Path(String otherFile) {
<span class="fc" id="L531">    int lastDot = otherFile.lastIndexOf(&quot;.&quot;);</span>
<span class="fc" id="L532">    String path = otherFile.substring(0, lastDot);</span>
<span class="fc" id="L533">    String ext = otherFile.substring(lastDot);</span>
<span class="fc" id="L534">    return path.replace('.', File.separatorChar) + ext;</span>
  }
  
  /**
   * Método que define algunas propiedades a partir de otras ya existentes.
   * &lt;p/&gt;
   * Por ahora se definen:
   * &lt;ul&gt;
   * &lt;li&gt;
   * &lt;code&gt;progen.user.home&lt;/code&gt;: ruta donde se encuentran los elementos que
   * definen el dominio concreto sobre el que se está trabajando.&lt;/li&gt;
   * &lt;/ul&gt;
   */
  @SuppressWarnings(&quot;static-access&quot;)
  private void calculateProperties() {
<span class="fc" id="L549">    String userHome = proGenProps.getProperty(&quot;progen.experiment.file&quot;);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">    if (userHome != null) {</span>
<span class="fc" id="L551">      setUserHome(userHome);</span>
    }
<span class="fc" id="L553">  }</span>

  private void setUserHome(String userHome) {
<span class="fc" id="L556">    userHome = userHome.substring(0, userHome.lastIndexOf(&quot;.&quot;));</span>
<span class="fc" id="L557">    setExperimentName(userHome);</span>
<span class="fc" id="L558">    userHome = userHome.substring(0, userHome.lastIndexOf(&quot;.&quot;) + 1);</span>

<span class="fc" id="L560">    proGenProps.properties.setProperty(&quot;progen.user.home&quot;, userHome);</span>
<span class="fc" id="L561">  }</span>

  private void setExperimentName(String userHome) {
    String experimentName;
<span class="fc" id="L565">    experimentName = userHome.substring(userHome.lastIndexOf(&quot;.&quot;) + 1, userHome.length());</span>
<span class="fc" id="L566">    proGenProps.properties.setProperty(&quot;progen.experiment.name&quot;, experimentName);</span>
<span class="fc" id="L567">  }</span>

  /**
   * Carga las propiedades definidas en el fichero que tiene por nombre el del
   * dominio del problema más un sufijo.
   * 
   * @param sufixFile
   *          El sufijo que se le añade al nombre del dominio para formar el
   *          fichero de propiedades.
   */
  private void loadOptionalFile(String sufixFile) {
    Properties otherProperties;
    Enumeration&lt;Object&gt; keys;
    String key;
    String value;
<span class="fc" id="L582">    StringBuilder optionalFilesLoaded = new StringBuilder();</span>

<span class="fc" id="L584">    String optionalFile = ProGenContext.getMandatoryProperty(&quot;progen.experiment.file&quot;);</span>
<span class="fc" id="L585">    optionalFile = optionalFile.replaceAll(&quot;\\.txt$&quot;, sufixFile).replace('.', File.separatorChar) + &quot;.txt&quot;;</span>
<span class="fc" id="L586">    optionalFilesLoaded.append(ProGenContext.getOptionalProperty(&quot;progen.optional.files&quot;, &quot;&quot;));</span>
<span class="fc" id="L587">    FileInputStream fis = null;</span>
    
    try {
<span class="nc" id="L590">      fis = new FileInputStream(optionalFile);</span>
<span class="nc" id="L591">      otherProperties = new Properties();</span>
<span class="nc" id="L592">      otherProperties.load(fis);</span>
<span class="nc" id="L593">      keys = otherProperties.keys();</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">      while (keys.hasMoreElements()) {</span>
<span class="nc" id="L595">        key = (String) keys.nextElement();</span>
<span class="nc" id="L596">        value = otherProperties.getProperty(key);</span>
<span class="nc" id="L597">        proGenProps.properties.put(key, value);</span>
      }
      
<span class="nc" id="L600">      optionalFilesLoaded.append(optionalFile);</span>
<span class="nc" id="L601">      optionalFilesLoaded.append(&quot;, &quot;);</span>
<span class="nc" id="L602">      ProGenContext.setProperty(&quot;progen.optional.files&quot;, optionalFilesLoaded.toString());</span>
<span class="fc" id="L603">    } catch (FileNotFoundException e) {</span>
      // do nothing, ignore
<span class="nc" id="L605">    } catch (IOException e) {</span>
      // do nothing, ignore
    } finally{
<span class="nc" id="L608">      try {</span>
<span class="pc bpc" id="L609" title="7 of 8 branches missed.">        if(fis != null){</span>
<span class="nc" id="L610">          fis.close();</span>
        }
<span class="nc" id="L612">      } catch (IOException e) {</span>
        // do nothing, ignore
<span class="pc" id="L614">      }</span>
<span class="nc" id="L615">    }</span>

<span class="fc" id="L617">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>