<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StandardCrossover.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ProGen</a> &gt; <a href="index.source.html" class="el_package">progen.kernel.evolution.operators</a> &gt; <span class="el_source">StandardCrossover.java</span></div><h1>StandardCrossover.java</h1><pre class="source lang-java linenums">package progen.kernel.evolution.operators;

import java.util.ArrayList;
import java.util.List;

import progen.context.ProGenContext;
import progen.kernel.evolution.GenneticOperator;
import progen.kernel.functions.Function;
import progen.kernel.population.Individual;
import progen.kernel.population.Population;
import progen.kernel.tree.Node;
import progen.kernel.tree.Tree;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * Implementación del operador genético de cruce estándar. El funcionamiento de
 * este operador consiste en seleccionar dos individuos de la población pasada
 * como parámetro, en función del selector que esté configurado.
 * 
 * Una vez seleccionados, se elige un nodo compatible de los dos árboles y se
 * intercambian los dichos nodos y nodos los nodos hijos a estos.
 * 
 * Se entenderá como nodo compatible con otro, todo aquel que contenga una
 * función que devuelva el mismo tipo de valor de retorno, esto es así, para que
 * cuando se intercambien los nodos, los nodos resultantes sigan estando bien
 * formados y sean palabras generadas por la gramática original de cada árbol.
 * 
 * @author jirsis
 * @since 1.0
 */
<span class="fc" id="L31">public class StandardCrossover extends GenneticOperator {</span>

  @Override
  public List&lt;Individual&gt; evolve(Population population) {
<span class="fc" id="L35">    final List&lt;Individual&gt; individuals = getSelector().select(population, 2);</span>
<span class="fc" id="L36">    final List&lt;Individual&gt; individualsCrossover = new ArrayList&lt;Individual&gt;();</span>
<span class="pc bpc" id="L37" title="1 of 2 branches missed.">    if (individuals.size() != 2) {</span>
<span class="nc" id="L38">      throw new SelectorSizeIncorrectValueException(2, individuals.size());</span>
    } else {
<span class="fc" id="L40">      final Individual mother = individuals.get(0);</span>
<span class="fc" id="L41">      final Individual father = individuals.get(1);</span>
<span class="fc" id="L42">      final Object[] treesSet = (Object[]) mother.getTrees().keySet().toArray();</span>
<span class="fc" id="L43">      final String key = (String) treesSet[(int) (Math.random() * treesSet.length)];</span>
<span class="fc" id="L44">      final Tree treeA = mother.getTrees().get(key);</span>
<span class="fc" id="L45">      final Tree treeB = father.getTrees().get(key);</span>

      // A ver que te parece así:
<span class="fc" id="L48">      boolean validCross = false;</span>
<span class="fc" id="L49">      int tries = 0;</span>
<span class="fc" id="L50">      boolean giveUp = false;</span>
<span class="pc bpc" id="L51" title="1 of 4 branches missed.">      while (!validCross &amp;&amp; !giveUp) {</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">        if (crossTree(treeA, treeB)) {</span>
<span class="nc" id="L53">          validCross = checkTrees(treeA, treeB);</span>
        }
<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (++tries &gt; 50) {</span>
<span class="fc" id="L56">          giveUp = true;</span>
        }
      }

<span class="pc bpc" id="L60" title="1 of 2 branches missed.">      if (validCross) {</span>
<span class="nc" id="L61">        individualsCrossover.add(mother);</span>
<span class="nc" id="L62">        individualsCrossover.add(father);</span>
      }

    }
<span class="fc" id="L66">    return individualsCrossover;</span>
  }

  /**
   * Forma de cruzar dos árboles distintos. Se devuelven los árboles cruzados
   * sobre los mismos parámetros, que serán modificados convenientemente.
   * 
   * @param treeA
   *          Primer árbol a cruzar.
   * @param treeB
   *          Segundo árbol a cruzar.
   * @return &lt;code&gt;true&lt;/code&gt; si ha sido posible seleccionar dos nodos y cruzar
   *         los árboles, &lt;code&gt;false&lt;/code&gt; en caso contrario.
   */
  private boolean crossTree(Tree treeA, Tree treeB) {
    int branchPos1;
    int branchPos2;
    List&lt;Node&gt; crossNodes;
    Node crossNode1;
    Node crossNode2;
    Node parent1;
    Node parent2;
<span class="fc" id="L88">    boolean treesCrossed = false;</span>

<span class="fc" id="L90">    crossNodes = selectNodes(treeA, treeB);</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">    if (crossNodes.size() &gt; 0) {</span>
<span class="nc" id="L92">      crossNode1 = crossNodes.get(0);</span>
<span class="nc" id="L93">      crossNode2 = crossNodes.get(1);</span>
      // guardamos los padres de los nodos de corte
<span class="nc" id="L95">      parent1 = crossNode1.getParent();</span>
<span class="nc" id="L96">      parent2 = crossNode2.getParent();</span>

      // guardamos la rama en la que estaban los nodos de corte
<span class="nc" id="L99">      branchPos1 = getBranch(crossNode1);</span>
<span class="nc" id="L100">      branchPos2 = getBranch(crossNode2);</span>
      // se separan los nodos seleccionados del arbol del que formaban parte
<span class="nc" id="L102">      crossNode1 = crossNode1.branch();</span>
<span class="nc" id="L103">      crossNode2 = crossNode2.branch();</span>
      // se asigna a cada padre, el nodo seleccionado del arbol opuesto
<span class="nc" id="L105">      parent1.setBranch(crossNode2, branchPos1);</span>
<span class="nc" id="L106">      parent2.setBranch(crossNode1, branchPos2);</span>
<span class="nc" id="L107">      treesCrossed = true;</span>
    }
<span class="fc" id="L109">    return treesCrossed;</span>
  }

  /**
   * Devuelve la posición que ocupa un nodo entre todos los nodos que comparten
   * su mismo padre.
   * 
   * @param node
   *          El nodo del que se desea saber que posición tiene entre todos sus
   *          hermanos.
   * @return La posición entre los distintos nodos hermano.
   */
  private int getBranch(Node node) {
<span class="nc" id="L122">    int branchPos = 0;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">    for (int i = 0; i &lt; node.getParent().getBranches().size(); i++) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">      if (node.getParent().getBranches().get(i) == node) {</span>
<span class="nc" id="L125">        branchPos = i;</span>
      }
    }
<span class="nc" id="L128">    return branchPos;</span>
  }

  /**
   * Forma de seleccionar dos nodos compatible a partir de dos árboles dados. Al
   * estar en un método separado, es suficiente con reimplementar este método en
   * los distintos tipos de operadores de árbol, para que funcione
   * correctamente.
   * 
   * @param treeA
   *          Uno de los árboles a cruzar.
   * @param treeB
   *          El otro árbol a cruzar.
   * @return Devuelve una lista, con dos elementos por lo general, que son dos
   *         nodos compatibles entre ellos y en los que se puede aplicar el
   *         operador de cruce.
   */
  protected List&lt;Node&gt; selectNodes(Tree treeA, Tree treeB) {
<span class="nc" id="L146">    final List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();</span>
    Node crossNode1;
    Node crossNode2;
    Function function1;
    Function function2;
    // se buscan los nodos de corte, sin tener en cuenta el nodo raiz
<span class="nc" id="L152">    crossNode1 = treeA.getNode(1 + (int) (Math.random() * treeA.getRoot().getTotalNodes() - 1));</span>
<span class="nc" id="L153">    crossNode2 = treeB.getNode(1 + (int) (Math.random() * treeB.getRoot().getTotalNodes() - 1));</span>
    // se recuperan las funciones de cada nodo
<span class="nc" id="L155">    function1 = crossNode1.getFunction().getFunction();</span>
<span class="nc" id="L156">    function2 = crossNode2.getFunction().getFunction();</span>
    // si la funcion no devuelve el mismo tipo, se busca otro nodo que si
    // que lo cumpla
<span class="nc bnc" id="L159" title="All 2 branches missed.">    while (!function1.getReturnType().equals(function2.getReturnType())) {</span>
<span class="nc" id="L160">      crossNode2 = treeB.getNode(1 + (int) (Math.random() * treeB.getRoot().getTotalNodes() - 1));</span>
<span class="nc" id="L161">      function2 = crossNode2.getFunction().getFunction();</span>
    }

<span class="nc" id="L164">    nodes.add(crossNode1);</span>
<span class="nc" id="L165">    nodes.add(crossNode2);</span>

<span class="nc" id="L167">    return nodes;</span>
  }

  @SuppressFBWarnings(value = &quot;NS_DANGEROUS_NON_SHORT_CIRCUIT&quot;, justification = &quot;It's mandatory to evaluate both trees&quot;)
  private boolean checkTrees(Tree treeA, Tree treeB) {
<span class="nc" id="L172">    return checkTreeSize(treeA) &amp; checkTreeSize(treeB);</span>
  }

  private boolean checkTreeSize(Tree tree) {
<span class="nc" id="L176">    final int maxNodes = ProGenContext.getOptionalProperty(&quot;progen.population.max-nodes&quot;, Integer.MAX_VALUE);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">    return tree.getRoot().getTotalNodes() &lt;= maxNodes;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>