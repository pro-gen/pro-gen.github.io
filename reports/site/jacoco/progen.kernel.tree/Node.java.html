<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Node.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ProGen</a> &gt; <a href="index.source.html" class="el_package">progen.kernel.tree</a> &gt; <span class="el_source">Node.java</span></div><h1>Node.java</h1><pre class="source lang-java linenums">package progen.kernel.tree;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import progen.kernel.functions.NullFunction;
import progen.kernel.grammar.GrammarNonTerminalSymbol;
import progen.kernel.grammar.GrammarTerminalSymbol;
import progen.kernel.grammar.Production;
import progen.userprogram.UserProgram;

/**
 * Clase que proporciona todos los métodos necesarios para gestionar un nodo,
 * así como de la modificación de su contenido y calculo de la ejecución del
 * mismo.
 * 
 * @author jirsis
 * @since 1.0
 * @version 2.0
 */
public class Node implements Cloneable {

    /** Número total de nodos que cuelgan de un nodo concreto */
    private int totalNodes;
    /** Profundidad a la que está dentro del árbol. */
    private int depth;
    /** Enlace al nodo padre. */
    private Node parent;
    /** Conjunto de nodos hijos */
    private List&lt;Node&gt; branches;
    /** Simbolo que representa a este nodo */
    private GrammarNonTerminalSymbol symbol;
    /** Función que contiene el nodo */
    private GrammarTerminalSymbol function;

    /**
     * Constructor que recibe el símbolo no terminal que contendrá el nodo.
     * 
     * @param symbol
     *            Símbolo que estará almacenado en el nodo.
     */
<span class="fc" id="L43">    public Node(GrammarNonTerminalSymbol symbol) {</span>
<span class="fc" id="L44">	this.parent = null;</span>
<span class="fc" id="L45">	this.branches = new ArrayList&lt;Node&gt;();</span>
<span class="fc" id="L46">	this.symbol = symbol;</span>
<span class="fc" id="L47">	this.function = new GrammarTerminalSymbol(new NullFunction(</span>
		symbol.toString()));
<span class="fc" id="L49">	this.depth = 0;</span>
<span class="fc" id="L50">	this.totalNodes = 1;</span>
<span class="fc" id="L51">    }</span>

    /**
     * Constructor de copia que recibe un nodo en el que basarse para duplicar.
     * 
     * @param node
     *            El nodo del que obtener la información de copia.
     * @param parent
     *            El nodo padre del nodo a copiar.
     */
<span class="fc" id="L61">    private Node(Node node, Node parent) {</span>
<span class="fc" id="L62">	this.depth = node.depth;</span>
<span class="fc" id="L63">	this.function = node.function;</span>
<span class="fc" id="L64">	this.parent = parent;</span>
<span class="fc" id="L65">	this.symbol = node.symbol;</span>
<span class="fc" id="L66">	this.totalNodes = node.totalNodes;</span>

<span class="fc" id="L68">	this.branches = new ArrayList&lt;Node&gt;();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">	for (Node branch : node.branches) {</span>
<span class="fc" id="L70">	    this.branches.add(new Node(branch, this));</span>
<span class="fc" id="L71">	}</span>

<span class="fc" id="L73">    }</span>

    /**
     * La clonación de un nodo implica crear nuevos nodos copia a partir de uno
     * dado. Se recomienda clonar a partir de un nodo raíz.
     * 
     * @return Node clonado.
     * @see java.lang.Object#clone()
     */
    public Node clone() {
	try {
<span class="fc" id="L84">	    super.clone();</span>
<span class="nc" id="L85">	} catch (CloneNotSupportedException e) {</span>
	    // ignore this exception
<span class="fc" id="L87">	}</span>
<span class="fc" id="L88">	Node clone = new Node(this, this.parent);</span>
<span class="fc" id="L89">	return clone;</span>
    }

    /**
     * Constructor de la clase que recibe un símbolo no terminal y el padre para
     * que queden enlazados.
     * 
     * @param symbol
     *            Símbolo no terminal que se almacenará en el nodo.
     * @param parent
     *            Nodo que será el pader del actual.
     */
<span class="fc" id="L101">    public Node(GrammarNonTerminalSymbol symbol, Node parent) {</span>
	// se enlazan el padre y el hijo
<span class="fc" id="L103">	this.parent = parent;</span>
<span class="fc" id="L104">	parent.getBranches().add(this);</span>

<span class="fc" id="L106">	this.branches = new ArrayList&lt;Node&gt;();</span>
<span class="fc" id="L107">	this.symbol = symbol;</span>
<span class="fc" id="L108">	this.function = new GrammarTerminalSymbol(new NullFunction(</span>
		symbol.toString()));
<span class="fc" id="L110">	this.depth = parent.getDepth() + 1;</span>
<span class="fc" id="L111">	this.totalNodes = 0;</span>
<span class="fc" id="L112">	addTotalNodes(1);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Especifica la función que contiene el nodo.
     * 
     * @param function
     *            La función que contiene el nodo.
     */
    public void setFunction(GrammarTerminalSymbol function) {
<span class="fc" id="L122">	this.function = function;</span>
<span class="fc" id="L123">    }</span>

    /**
     * Devuelve el número total de nodos que cuelgan de uno concreto.
     * 
     * @return el número total de nodos.
     */
    public int getTotalNodes() {
<span class="fc" id="L131">	return totalNodes;</span>
    }

    /**
     * Devuelve el nodo padre del nodo actual
     * 
     * @return el padre del nodo actual o &lt;code&gt;null&lt;/code&gt; en caso de ser la
     *         raíz.
     */
    public Node getParent() {
<span class="fc" id="L141">	return parent;</span>
    }

    /**
     * Devuelve la función que contiene en el nodo.
     * 
     * @return la función que contiene el nodo.
     */
    public GrammarTerminalSymbol getFunction() {
<span class="fc" id="L150">	return function;</span>
    }

    /**
     * Devuelve el símbolo no terminal de la gramática que generó este nodo.
     * 
     * @return el símbolo no terminal de la gramática que generó el nodo.
     */
    public GrammarNonTerminalSymbol getSymbol() {
<span class="fc" id="L159">	return symbol;</span>
    }

    /**
     * Devuelve una lista con todas las ramas del nodo.
     * 
     * @return conjunto de ramas que cuelgan del nodo.
     */
    public List&lt;Node&gt; getBranches() {
<span class="fc" id="L168">	return branches;</span>
    }

    /**
     * Devuelve la profundidad a la que se encuentra un nodo.
     * 
     * @return la profundidad a la que está el nodo.
     */
    public int getDepth() {
<span class="fc" id="L177">	return depth;</span>
    }

    /**
     * Define a que profundidad se encunetra el nodo y actualiza la profundidad
     * de todas sus ramas.
     * 
     * @param depth
     *            la nueva profundidad.
     */
    private void setDepth(int depth) {
<span class="fc" id="L188">	this.depth = depth;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">	for (Node node : branches) {</span>
<span class="fc" id="L190">	    node.setDepth(depth + 1);</span>
<span class="fc" id="L191">	}</span>
<span class="fc" id="L192">    }</span>

    /**
     * Completa la información del nodo a partir de una producción pasada por
     * parámetro.
     * 
     * @param production
     *            La producción de la que obtiene la información.
     */
    public void setProduction(Production production) {
<span class="fc" id="L202">	symbol = production.getLeft();</span>
<span class="fc" id="L203">	function = production.getFunction();</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">	for (int i = 0; i &lt; production.getArgs().length; i++) {</span>
<span class="fc" id="L205">	    new Node(production.getArgs()[i], this);</span>
	}
<span class="fc" id="L207">    }</span>

    /**
     * Define una rama en una posición concreta, actualizando la información
     * relativa a la posición dentro del árbol del que forma parte.
     * 
     * @param branch
     *            Rama a colocar.
     * @param branchPosition
     *            Posición de la rama.
     */
    public void setBranch(Node branch, int branchPosition) {
<span class="fc" id="L219">	this.addTotalNodes(branch.getTotalNodes());</span>
<span class="fc" id="L220">	branch.parent = this;</span>
<span class="fc" id="L221">	branch.setDepth(depth + 1);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">	if (branchPosition &gt; branches.size()) {</span>
<span class="nc" id="L223">	    branches.add(branchPosition - 1, branch);</span>
	} else {
<span class="fc" id="L225">	    branches.add(branchPosition, branch);</span>
	}

<span class="fc" id="L228">    }</span>

    /**
     * Separa al nodo del árbol del que forma parte quedando como raíz del
     * subárbol que definía. Actualiza y define todos los atributos de tal forma
     * que es la raíz de un árbol.
     * 
     * @return El nodo ráiz del subárbol que definía.
     */
    public Node branch() {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">	if (!this.isRoot()) {</span>
<span class="fc" id="L239">	    parent.addTotalNodes(-this.totalNodes);</span>

<span class="fc" id="L241">	    int thisNode = 0;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">	    for (int i = 0; i &lt; parent.getBranches().size(); i++) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">		if (this == parent.getBranches().get(i)) {</span>
<span class="fc" id="L244">		    thisNode = i;</span>
		}
	    }
<span class="fc" id="L247">	    parent.branches.remove(thisNode);</span>
<span class="fc" id="L248">	    parent = null;</span>
<span class="fc" id="L249">	    depth = 0;</span>
	}
<span class="fc" id="L251">	return this;</span>
    }

    /**
     * Actualiza el número total de nodos que cuelgan de un nodo y de los nodos
     * que están por encima de él hasta llegar a la raíz.
     * 
     * @param n
     *            El número de nodos a actualizar.
     */
    public void addTotalNodes(int n) {
<span class="fc bfc" id="L262" title="All 2 branches covered.">	if (parent != null) {</span>
<span class="fc" id="L263">	    parent.addTotalNodes(n);</span>
	}
<span class="fc" id="L265">	this.totalNodes += n;</span>
<span class="fc" id="L266">    }</span>

    /**
     * Limpia el contenido del nodo en concreto y de todas las ramas que tenía.
     */
    public void clearNode() {
<span class="fc" id="L272">	function = new GrammarTerminalSymbol(</span>
		new NullFunction(symbol.toString()));
<span class="fc bfc" id="L274" title="All 2 branches covered.">	for (int i = 0; i &lt; branches.size(); i++) {</span>
<span class="fc" id="L275">	    addTotalNodes(-branches.get(i).getTotalNodes());</span>
	}
<span class="fc" id="L277">	branches.clear();</span>

<span class="fc" id="L279">    }</span>

    /**
     * Comprueba si el nodo es un nodo hoja o no, esto es, si tiene alguna rama
     * o no.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; si es una hoja y &lt;code&gt;false&lt;/code&gt; en caso
     *         contrario.
     */
    public boolean isLeaf() {
<span class="fc bfc" id="L289" title="All 2 branches covered.">	return branches.size() == 0;</span>
    }

    /**
     * Comprueba si el nodo es un nodo raíz o no, esto es, si tiene algún nodo
     * que sea padre suyo.
     * 
     * @return &lt;code&gt;true&lt;/code&gt; si es la raíz y &lt;code&gt;false&lt;/code&gt; en caso
     *         contrario.
     */
    public boolean isRoot() {
<span class="fc bfc" id="L300" title="All 2 branches covered.">	return parent == null;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="fc" id="L310">	StringBuilder stb = new StringBuilder();</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">	if (isLeaf()) {</span>
<span class="fc" id="L312">	    stb.append(function);</span>
	} else {
<span class="fc" id="L314">	    stb.append(&quot;(&quot; + function);</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">	    for (int i = 0; i &lt; branches.size(); i++) {</span>
<span class="fc" id="L316">		stb.append(&quot; &quot; + branches.get(i).toString());</span>
	    }
<span class="fc" id="L318">	    stb.append(&quot; )&quot;);</span>
	}
<span class="fc" id="L320">	return stb.toString();</span>
    }

    /**
     * Evalúa el nodo llamando a la función que contiene.
     * 
     * @param userProgram
     *            Representación del dominio implementado por el usuario.
     * @param returnAddr
     *            Dirección de retorno de las llamadas a ADFs.
     * @return Valor después de ejecutar la función del nodo.
     */
    public Object evaluate(UserProgram userProgram,
	    HashMap&lt;String, Object&gt; returnAddr) {
<span class="fc" id="L334">	return function.getFunction().evaluate(branches, userProgram,</span>
		returnAddr);
    }

    /**
     * Devuelve el nodo que se encuentra en la posición solicitada, recorriendo
     * todos los hijos siguiendo en pre-orden.
     * 
     * @param position
     *            La posición del nodo buscado.
     * @return El nodo que está en la posición solicitada o &lt;code&gt;null&lt;/code&gt; si
     *         solicitó un nodo fuera de los rangos permitidos.
     */
    public Node getNode(int position) {
<span class="fc" id="L348">	Node node = null;</span>
	// si se busca un numero &lt; 0 o mayor que el numero de nodos total
<span class="fc bfc" id="L350" title="All 4 branches covered.">	if (position &lt; this.getTotalNodes() &amp;&amp; position &gt;= 0) {</span>
<span class="fc" id="L351">	    node = findNode(position);</span>
	}
<span class="fc" id="L353">	return node;</span>
    }

    /**
     * Método recursivo que recorre todos los nodos a partir del actual buscando
     * el que esté en la posción
     * 
     * @param position
     *            Posición del nodo que se quiere buscar.
     * @return Nodo que está en la posición requerida.
     */
    private Node findNode(int position) {
<span class="fc" id="L365">	Node node = null;</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">	if (position == 0) {</span>
<span class="fc" id="L367">	    node = this;</span>
	} else {
<span class="fc bfc" id="L369" title="All 4 branches covered.">	    for (int i = 0; node == null &amp;&amp; i &lt; branches.size(); i++) {</span>
<span class="fc" id="L370">		node = branches.get(i).findNode(position - 1);</span>
<span class="fc" id="L371">		position -= branches.get(i).getTotalNodes();</span>
	    }
	}
<span class="fc" id="L374">	return node;</span>
    }

    /**
     * Devuelve la profundidad a la que se encuentra el nodo más profundo de
     * todos los hijos que tenga un nodo concreto.
     * 
     * @return La profundidad a la que se encuentra el nodo que está más
     *         profundo.
     */
    public int getMaximunDepth() {
<span class="fc" id="L385">	int maxDepth = 0;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">	if (this.isLeaf()) {</span>
<span class="fc" id="L387">	    maxDepth = depth;</span>
	} else {
<span class="fc bfc" id="L389" title="All 2 branches covered.">	    for (Node branch : branches) {</span>
<span class="fc" id="L390">		maxDepth = Math.max(maxDepth, branch.getMaximunDepth());</span>
<span class="fc" id="L391">	    }</span>
	}
<span class="fc" id="L393">	return maxDepth;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>