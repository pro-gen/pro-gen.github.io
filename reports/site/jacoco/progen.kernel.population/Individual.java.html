<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Individual.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ProGen</a> &gt; <a href="index.source.html" class="el_package">progen.kernel.population</a> &gt; <span class="el_source">Individual.java</span></div><h1>Individual.java</h1><pre class="source lang-java linenums">package progen.kernel.population;

import java.util.HashMap;

import progen.context.ProGenContext;
import progen.kernel.functions.ADF;
import progen.kernel.functions.Terminal;
import progen.kernel.grammar.Grammar;
import progen.kernel.grammar.GrammarTerminalSymbol;
import progen.kernel.tree.Tree;
import progen.roles.Task;
import progen.userprogram.UserProgram;

/**
 * Clase que representa la información necesaria para representar un individuo
 * completo en programación genética.
 * 
 * @author jirsis
 * @since 1.0
 * 
 */
public class Individual implements Task, Comparable&lt;Individual&gt;, Cloneable {
    /** Para serialización */
    private static final long serialVersionUID = -3776497075849167016L;

    /**
     * Árboles que definen el individuo como tal. Se almacenan tanto RPBs como
     * ADFs y se identifican siguiendo la nomenclatura RPBi, ADFi, donde i es un
     * número [0, máximo árbol definido).
     */
    private HashMap&lt;String, Tree&gt; trees;

    /**
     * Resultados de la evaluación de los árboles. Únicamente tiene sentido
     * almacenar el resultado de los RPB dado que son éstos los únicos que
     * pueden ser evaluados.
     */
    private HashMap&lt;String, Object&gt; results;

    /**
     * Gramáticas que generan todos y cada unos de los árboles que forman el
     * individuo concreto.
     */
    HashMap&lt;String, Grammar&gt; grammars;

    /**
     * Número total de árboles RPB en un individuo concreto.
     */
    private int totalRPB;

    /**
     * Número total de árboles ADF en un individuo concreto.
     */
    private int totalADF;

    /**
     * Valor del &lt;code&gt;raw-fitness&lt;/code&gt; resultante de ejecutar la función de
     * evaluación para este individuo.
     */
    private double rawFitness;

    /**
     * Indica si es necesario reevaluar los árboles de un individuo antes de
     * devolver los resultados. Es una optimización que evita tener que
     * recalcular constantemente todos los árboles aún cuando no hayan cambiado
     * los valores de las variables definidas en dichos árboles.
     */
    private boolean updated;

    /**
     * Tabla en la que se almacena el valor concreto de todas las variables
     * disponibles en la ejecución de un individuo.
     */
    private HashMap&lt;String, Object&gt; variables;

    /**
     * Representación del individuo para ser impresa de alguna forma. Modifica
     * la versión estándar en la que se muestran todos los árboles (ADF y RPB)
     * que definen un individuo.
     */
    private String printabeIndividual;

    /**
     * Constructor genérico de la clase. Recibe el conjunto de gramáticas que se
     * utilizarán para generar los árboles que definen el indidivuo.
     * 
     * @param grammars
     *            Gramáticas que generarán todos los árboles, tanto RPBs como
     *            ADFs que conforman un individuo concreto.
     */
<span class="fc" id="L91">    public Individual(HashMap&lt;String, Grammar&gt; grammars) {</span>
	Tree tree;
<span class="fc" id="L93">	trees = new HashMap&lt;String, Tree&gt;();</span>
<span class="fc" id="L94">	results = new HashMap&lt;String, Object&gt;();</span>

<span class="fc" id="L96">	totalRPB = ProGenContext.getOptionalProperty(&quot;progen.total.RPB&quot;, 1);</span>
<span class="fc" id="L97">	ProGenContext.setProperty(&quot;progen.total.RPB&quot;, totalRPB+&quot;&quot;);</span>
<span class="fc" id="L98">	totalADF = ProGenContext.getOptionalProperty(&quot;progen.total.ADF&quot;, 0);</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">	for (int i = 0; i &lt; totalRPB; i++) {</span>
<span class="fc" id="L101">	    tree = new Tree();</span>
<span class="fc" id="L102">	    tree.generate(grammars.get(&quot;RPB&quot; + i));</span>
<span class="fc" id="L103">	    trees.put(&quot;RPB&quot; + i, tree);</span>
	}
	
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">	for (int i = 0; i &lt; totalADF; i++) {</span>
<span class="nc" id="L107">	    tree = new Tree();</span>
<span class="nc" id="L108">	    tree.generate(grammars.get(&quot;ADF&quot; + i));</span>
<span class="nc" id="L109">	    trees.put(&quot;ADF&quot; + i, tree);</span>
	}

<span class="fc" id="L112">	this.grammars = grammars;</span>

<span class="fc" id="L114">	this.rawFitness = Double.MAX_VALUE;</span>

<span class="fc" id="L116">	this.updated = true;</span>

<span class="fc" id="L118">	this.variables = new HashMap&lt;String, Object&gt;();</span>

<span class="fc" id="L120">	this.printabeIndividual = null;</span>
<span class="fc" id="L121">    }</span>

    /**
     * Constructor de copia que crea un nuevo individuo a partir de otro
     * proporcionado como parámetro.
     * 
     * @param individual
     *            El individuo a copiar.
     */
<span class="fc" id="L130">    public Individual(Individual individual) {</span>
<span class="fc" id="L131">	this.rawFitness = individual.rawFitness;</span>
<span class="fc" id="L132">	this.results = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L133">	this.totalRPB = individual.totalRPB;</span>
<span class="fc" id="L134">	this.totalADF = individual.totalADF;</span>
<span class="fc" id="L135">	this.grammars = individual.grammars;</span>
<span class="fc" id="L136">	this.updated = individual.updated;</span>
<span class="fc" id="L137">	this.trees = new HashMap&lt;String, Tree&gt;();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">	for (String key : individual.trees.keySet()) {</span>
<span class="fc" id="L139">	    this.trees.put(key, new Tree(individual.trees.get(key)));</span>
<span class="fc" id="L140">	}</span>
<span class="fc" id="L141">	this.variables = new HashMap&lt;String, Object&gt;();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">	for (String key : individual.variables.keySet()) {</span>
<span class="nc" id="L143">	    this.variables.put(key, individual.variables.get(key));</span>
<span class="nc" id="L144">	}</span>

<span class="fc" id="L146">    }</span>

    /**
     * Devuelve los árboles que contiene el individuo.
     * 
     * @return Los árboles que contiene el individuo.
     */
    public HashMap&lt;String, Tree&gt; getTrees() {
<span class="fc" id="L154">	return trees;</span>
    }

    /**
     * Devuelve las gramáticas utilizadas para generar los distintos árboles.
     * 
     * @return Las gramáticas utilizadas para generar los distintos árboles.
     */
    public HashMap&lt;String, Grammar&gt; getGrammars() {
<span class="nc" id="L163">	return grammars;</span>
    }

    /**
     * Representación en forma de &lt;code&gt;String&lt;/code&gt; de un individuo, es decir,
     * se obtiene representación de todos los árboles que contiene.
     * 
     * @return La representación del individuo.
     */
    @Override
    public String toString() {
<span class="nc" id="L174">	StringBuilder stb = new StringBuilder();</span>

<span class="nc bnc" id="L176" title="All 4 branches missed.">	if (this.printabeIndividual != null</span>
		&amp;&amp; this.printabeIndividual.length() &gt; 0) {
<span class="nc" id="L178">	    stb.append(printabeIndividual);</span>
	} else {
<span class="nc" id="L180">	    int RPB = 0;</span>
<span class="nc" id="L181">	    int adf = 0;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">	    while (trees.get(&quot;RPB&quot; + RPB) != null) {</span>
<span class="nc" id="L183">		stb.append(&quot;\nRPB&quot; + RPB + &quot;: &quot; + trees.get(&quot;RPB&quot; + RPB));</span>
<span class="nc" id="L184">		RPB++;</span>
	    }
<span class="nc bnc" id="L186" title="All 2 branches missed.">	    while (trees.get(&quot;ADF&quot; + adf) != null) {</span>
<span class="nc" id="L187">		stb.append(&quot;\nADF&quot; + adf + &quot;: &quot; + trees.get(&quot;ADF&quot; + adf));</span>
<span class="nc" id="L188">		adf++;</span>
	    }
	}
<span class="nc" id="L191">	return stb.toString();</span>
    }

    /**
     * Definición de un valor concreto para todas las variables que existan en
     * cualquier árbol.
     * 
     * @param variable
     *            Identificador de la variable a la que se le va a asignar el
     *            valor.
     * @param value
     *            Valor concreto que tendrá la variable.
     */
    public void setVariable(String variable, Object value) {
<span class="nc" id="L205">	this.updated = true;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">	for (String idGrammar : grammars.keySet()) {</span>
<span class="nc" id="L207">	    Grammar grammar = grammars.get(idGrammar);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">	    for (GrammarTerminalSymbol function : grammar</span>
		    .getGrammarTerminalSymbols()) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (function.getSymbol().equals(variable)) {</span>
<span class="nc" id="L211">		    Terminal var = (Terminal) function.getFunction();</span>
<span class="nc" id="L212">		    var.setValue(value);</span>
		}
<span class="nc" id="L214">	    }</span>
<span class="nc" id="L215">	}</span>
<span class="nc" id="L216">    }</span>

    /**
     * Función que evalúa y obtiene un resultado de la ejecución de todos los
     * árboles que tiene un individuo concreto. El resultado se deja almacenado
     * en la variable para tal efecto.
     * 
     * @param variables
     *            Almacén que contiene todas las variables definidas por un
     *            identificador y su valor concreto.
     * @param userprogram
     *            Definición del problema que ha tenido que implementar el
     *            usuario.
     */
    private void evaluateTree(HashMap&lt;String, Object&gt; variables,
	    UserProgram userprogram) {
	// se actualizan los ADF correspondientes para que utilicen el arbol de
	// este individuo
<span class="nc bnc" id="L234" title="All 2 branches missed.">	for (int i = 0; i &lt; totalADF; i++) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">	    for (int j = 0; j &lt; totalRPB; j++) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">		for (GrammarTerminalSymbol adf : grammars.get(&quot;RPB&quot; + j)</span>
			.getGrammarTerminalSymbols()) {
<span class="nc bnc" id="L238" title="All 2 branches missed.">		    if (adf.getSymbol().compareTo(&quot;ADF&quot; + i) == 0) {</span>
<span class="nc" id="L239">			((ADF) adf.getFunction()).setADFTree(trees.get(&quot;ADF&quot;</span>
				+ i));
		    }
<span class="nc" id="L242">		}</span>
	    }
	}
<span class="nc bnc" id="L245" title="All 2 branches missed.">	for (int i = 0; i &lt; totalRPB; i++) {</span>
<span class="nc" id="L246">	    results.put(&quot;RPB&quot; + i,</span>
		    trees.get(&quot;RPB&quot; + i).evaluate(userprogram, variables));
	}
<span class="nc" id="L249">	this.updated = false;</span>
<span class="nc" id="L250">    }</span>

    /**
     * Devuelve el resultado de ejecutar el árbol solicitado como parámetro.
     * Únicamente tiene sentido solicitar los resultados de los árboles de tipo
     * RPB.
     * 
     * @param idTree
     *            Identificador del árbol del que se quiere obtener el resultado
     *            de su ejecución.
     * @param userProgram
     *            Referencia al programa modelado por el usuario.
     * @return Object del tipo que devuelve el function set que defina la
     *         gramática que se utilizá para definir ese árbol.
     */
    public Object evaluate(String idTree, UserProgram userProgram) {
            //TODO: comprobar que se está solicianto de un RPB, en caso contrario dar un fallo.
<span class="nc bnc" id="L267" title="All 2 branches missed.">	if (updated) {</span>
<span class="nc" id="L268">	    this.evaluateTree(variables, userProgram);</span>
	}
<span class="nc" id="L270">	return results.get(idTree);</span>
    }

    /**
     * Devuelve únicamente el valor de la ejecución del árbol identificado como
     * &lt;code&gt;RPB0&lt;/code&gt;, ya que no se tiene sentido definir un individuo en el
     * que no exista ni siquiera este árbol.
     * 
     * @param userProgram
     *            Referencia al programa modelado por el usuario. *
     * @return Object del tipo que devuelve el function-set que defina la
     *         gramática que se utilizá para definir ese árbol.
     */
    public Object evaluate(UserProgram userProgram) {
<span class="nc" id="L284">	return this.evaluate(&quot;RPB0&quot;, userProgram);</span>
    }

    /**
     * Especifica el valor del &lt;i&gt;rawFitness&lt;/i&gt; de este individuo, según se
     * haya definido en el UserProgram de un problema concreto
     * 
     * @see progen.userprogram.UserProgram
     * 
     * @param fitness
     *            el valor del &lt;i&gt;rawFitness&lt;/i&gt;.
     */
    public void setRawFitness(double fitness) {
<span class="nc" id="L297">	this.rawFitness = fitness;</span>
<span class="nc" id="L298">    }</span>

    /**
     * Devuelve el valor del &lt;i&gt;rawFitness&lt;/i&gt; de este individuo.
     * 
     * @return fitness el valor del &lt;i&gt;rawFitness&lt;/i&gt; de este individuo.
     */
    public double getRawFitness() {
<span class="nc" id="L306">	return rawFitness;</span>
    }

    /**
     * Devuelve el valor del &lt;i&gt;adjustedFitness&lt;/i&gt; según la definición:
     * &lt;code&gt;adjustedFitness=1/(1+rawFitness);&lt;/code&gt;
     * 
     * @return el valor del &lt;i&gt;adjustedFitness&lt;/i&gt;
     */
    public double getAdjustedFitness() {
<span class="fc" id="L316">	return 1 / (1 + rawFitness);</span>
    }

    /*
     * (non-Javadoc)
     * @see progen.roles.Task#calculate(progen.userprogram.UserProgram)
     */
    @Override
    public void calculate(UserProgram userProgram) {
<span class="nc" id="L325">	this.rawFitness = userProgram.fitness(this);</span>
<span class="nc" id="L326">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see progen.roles.Task#isDone()
     */
    @Override
    public boolean isDone() {
<span class="nc bnc" id="L335" title="All 2 branches missed.">	return !updated;</span>
    }

    /**
     * Compara un individuo con otro proporcionado como parámetro.
     * 
     * @param other
     *            El individuo con el que comparar.
     * @return Devuelve la diferencia entre el rawFitness de los dos, de la
     *         forma &lt;code&gt;this-other&lt;/code&gt;
     */
    @Override
    public int compareTo(Individual other) {
<span class="fc" id="L348">	return Double.compare(this.rawFitness, other.rawFitness);</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object other) {
<span class="fc" id="L358">	boolean equals = false;</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">	if (other instanceof Individual) {</span>
<span class="fc" id="L360">	    equals = this.equals((Individual) other);</span>
	} else {
<span class="nc" id="L362">	    equals = false;</span>
	}
<span class="fc" id="L364">	return equals;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="nc" id="L374">	return toString().hashCode();</span>
    }

    /**
     * Compara dos individuos para comprobar si son iguales o no. Se considerará
     * que dos individuos son iguales únicamente si todos sus árboles son
     * iguales.
     * 
     * @param other
     *            Individuo con el que comparar
     * @return &lt;code&gt;true&lt;/code&gt; si los dos individuos son iguales.
     */
    public boolean equals(Individual other) {
<span class="fc" id="L387">	boolean equals = true;</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">	if (other == null) {</span>
<span class="nc" id="L389">	    equals = false;</span>
	} else {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">	    for (int i = 0; i &lt; totalRPB; i++) {</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">		equals = equals</span>
			&amp;&amp; trees.get(&quot;RPB&quot; + i)
				.toString()
				.compareTo(
					other.getTrees().get(&quot;RPB&quot; + i)
						.toString()) == 0;
	    }
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">	    for (int i = 0; i &lt; totalADF; i++) {</span>
<span class="nc bnc" id="L400" title="All 4 branches missed.">		equals = equals</span>
			&amp;&amp; trees.get(&quot;ADF&quot; + i)
				.toString()
				.compareTo(
					other.getTrees().get(&quot;ADF&quot; + i)
						.toString()) == 0;
	    }
	}
<span class="fc" id="L408">	return equals;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see progen.roles.Task#getCalculateResult()
     */
    @Override
    public Object getCalculateResult() {
<span class="nc" id="L418">	return this;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#clone()
     */
    @Override
    public Individual clone() {
	try {
<span class="fc" id="L429">	    super.clone();</span>
<span class="nc" id="L430">	} catch (CloneNotSupportedException e) {</span>
	    // ignore this
<span class="fc" id="L432">	}</span>
<span class="fc" id="L433">	return new Individual(this);</span>
    }

    /**
     * Devuelve el número total de árboles RPB que componen el individuo.
     * 
     * @return el número total de RPB.
     */
    public int getTotalRPB() {
<span class="nc" id="L442">	return totalRPB;</span>
    }

    /**
     * Devuelve el número total de árboles ADF que componen el individuo.
     * 
     * @return el número total de ADF.
     */
    public int getTotalADF() {
<span class="nc" id="L451">	return totalADF;</span>
    }

    /**
     * @param printable
     */
    public void setPrintableIndividual(String printable) {
<span class="nc" id="L458">	this.printabeIndividual = printable;</span>
<span class="nc" id="L459">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>