<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Grammar.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ProGen</a> &gt; <a href="index.source.html" class="el_package">progen.kernel.grammar</a> &gt; <span class="el_source">Grammar.java</span></div><h1>Grammar.java</h1><pre class="source lang-java linenums">package progen.kernel.grammar;

import java.util.ArrayList;
import java.util.List;

import progen.ProGenException;
import progen.context.ProGenContext;
import progen.kernel.functions.ARG;
import progen.kernel.functions.Function;
import progen.kernel.grammar.validations.GrammarCheck;
import progen.kernel.hypergp.HGPGrammar;

/**
 * Una gramática se define como una cuádrupla compuesta por:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Axioma: Símbolo no terminal del que se empieza a derivar todo el árbol de
 * generación.&lt;/li&gt;
 * &lt;li&gt;
 * No terminales: Conjunto de símbolos auxiliares que no pueden aparecer en la
 * palabra final que se defina a través de la gramática. Son símbolos auxiliares
 * que ayudan a evolucionar cada palabra intermedia hasta una final.&lt;/li&gt;
 * &lt;li&gt;
 * Terminales: Conjunto de símbolos que aparecen en la palabra final.&lt;/li&gt;
 * &lt;li&gt;
 * Producciones: Conjunto de reglas que se utilizan para generar una palabra
 * válida.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * La gramáticas válidas para ProGen son gramáticas de tipo 2 (independientes de
 * contexto) en la que todas las producciones que se definan, tienen que ser
 * recursivas lineales a izquierdas.
 * 
 * @author jirsis
 * @since 2.0
 */
public class Grammar {

  /** Identificador del &lt;i&gt;function-set&lt;/i&gt; que define la gramática. */
  private String functionSetId;

  /** Conjunto de símbolos terminales. */
  private List&lt;GrammarTerminalSymbol&gt; grammarTerminalSymbols;
  /** Conjunto de símbolos no terminales. */
  private List&lt;GrammarNonTerminalSymbol&gt; grammarNonTerminalSymbols;
  /** Axioma. */
  private GrammarNonTerminalSymbol axiom;
  /**
   * Conjunto de producciones que generarán una palabra válida por el lenguaje
   * definido.
   */
  private List&lt;Production&gt; productions;

  /**
   * Constructor de la clase en la que se espera un identificador de árbol, del
   * estilo &quot;RPB&quot; o &quot;ADF&quot;, de tal forma que se inicialicen los valores y se
   * realicen las comprobaciones pertinentes para asegurarse de que la gramática
   * está bien formada y no tenga problemas que impidan ejecutar más adelante
   * los árboles generados.
   * 
   * @param idTree
   *          Identificador del árbol que utilizará esta gramática. Deberá
   *          recibir algo del estilo &quot;RPBx&quot; o &quot;ADFx&quot;, donde x es un entero
   *          &amp;gt;= 0.
   */
<span class="fc" id="L66">  protected Grammar(String idTree) {</span>
    String returnValue;

<span class="fc" id="L69">    functionSetId = ProGenContext.getMandatoryProperty(&quot;progen.&quot; + idTree + &quot;.functionSet&quot;);</span>
<span class="fc" id="L70">    returnValue = ProGenContext.getMandatoryProperty(&quot;progen.functionSet&quot; + functionSetId + &quot;.return&quot;);</span>

<span class="fc" id="L72">    axiom = new GrammarNonTerminalSymbol(&quot;Ax&quot;, returnValue);</span>
<span class="fc" id="L73">    grammarTerminalSymbols = new ArrayList&lt;GrammarTerminalSymbol&gt;();</span>
<span class="fc" id="L74">    grammarNonTerminalSymbols = new ArrayList&lt;GrammarNonTerminalSymbol&gt;();</span>
<span class="fc" id="L75">    grammarNonTerminalSymbols.add(axiom);</span>
<span class="fc" id="L76">    productions = new ArrayList&lt;Production&gt;();</span>

<span class="pc bpc" id="L78" title="1 of 2 branches missed.">    if (!loadGrammar(Integer.parseInt(functionSetId))) {</span>
<span class="nc" id="L79">      throw new DuplicatedFunctionException(idTree);</span>
    }

<span class="pc bpc" id="L82" title="1 of 2 branches missed.">    if (idTree.startsWith(&quot;ADF&quot;)) {</span>
<span class="nc" id="L83">      generateADFProductions(idTree);</span>
    }

    try {
<span class="fc" id="L87">      validate();</span>
<span class="nc" id="L88">    } catch (GrammarNotValidException e) {</span>
<span class="nc" id="L89">      throw new ProGenException(e.getMessage());</span>
<span class="fc" id="L90">    }</span>
<span class="fc" id="L91">  }</span>

  /**
   * Devuelve el function-set que definió esta gramática.
   * 
   * @return El function-set que definió esta gramática.
   */
  public String getFunctionSetId() {
<span class="nc" id="L99">    return functionSetId;</span>
  }

  /**
   * Devuelve el símbolo no terminal por el que se empieza a derivar toda la
   * palabra.
   * 
   * @return El axioma de la gramática.
   */
  public GrammarNonTerminalSymbol getAxiom() {
<span class="fc" id="L109">    return axiom;</span>
  }

  /**
   * Devuelve el conjunto de producciones que define esta gramática.
   * 
   * @return El conjunto de producciones.
   * @see progen.kernel.grammar.Production
   */
  public List&lt;Production&gt; getProductions() {
<span class="fc" id="L119">    return productions;</span>
  }

  /**
   * Devuelve el conjunto de producciones en las que se utiliza el símbolo
   * proporcionado como parámetro para poder ejecutar esa producción.
   * 
   * @param symbol
   *          símbolo que aparece en la parte izquierda de la producción.
   * @return Conjunto de producciones que se pueden derivar a partir del
   *         símbolo.
   */
  public List&lt;Production&gt; getProductions(GrammarSymbol symbol) {
<span class="nc" id="L132">    return getProductions((GrammarNonTerminalSymbol) symbol);</span>
  }

  /**
   * Devuelve el conjunto de producciones en las que se utiliza el símbolo no
   * terminal proporcionado como parámetro para poder ejecutar esa producción.
   * 
   * @param left
   *          símbolo que aparece en la parte izquierda de la producción.
   * @return Conjunto de producciones que se pueden derivar a partir del
   *         símbolo.
   */
  public List&lt;Production&gt; getProductions(GrammarNonTerminalSymbol left) {
<span class="fc" id="L145">    List&lt;Production&gt; prods = new ArrayList&lt;Production&gt;();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">    for (Production p : productions) {</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">      if (p.getLeft().compareTo(left) == 0) {</span>
<span class="fc" id="L148">        prods.add(p);</span>
      }
<span class="fc" id="L150">    }</span>
<span class="fc" id="L151">    return prods;</span>
  }

  public List&lt;Production&gt; getProductionsCompatibleWithFunction(GrammarNonTerminalSymbol nonTerminal, GrammarTerminalSymbol terminal) {
<span class="nc" id="L155">    List&lt;Production&gt; prods = new ArrayList&lt;Production&gt;();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    for (Production p : productions) {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      if (p.getLeft().compareTo(nonTerminal) == 0) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (terminal.getFunction().isCompatibleWith(p.getFunction().getFunction())) {</span>
<span class="nc" id="L159">          prods.add(p);</span>
        }
      }
<span class="nc" id="L162">    }</span>
<span class="nc" id="L163">    return prods;</span>
  }

  /**
   * Devuelve el conjunto de producciones en las que aparece en la parte
   * izquierda el símbolo deseado, de tal forma que el orden de las producciones
   * del conjunto es aleatorio.
   * 
   * @param left
   *          Símbolo que genera la producción.
   * @return El conjunto de producciones que genera dicho símbolo.
   */
  public List&lt;Production&gt; getRandomProductions(GrammarNonTerminalSymbol left) {
<span class="fc" id="L176">    List&lt;Production&gt; productions = this.getProductions(left);</span>
<span class="fc" id="L177">    List&lt;Production&gt; random = new ArrayList&lt;Production&gt;();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">    while (productions.size() != 0) {</span>
<span class="fc" id="L179">      random.add(productions.remove((int) (Math.random() * productions.size())));</span>
    }
<span class="fc" id="L181">    return random;</span>
  }

  /**
   * Devuelve el conjunto de símbolos terminales de la gramática.
   * 
   * @return El conjunto de símbolos terminales de la gramática.
   */
  public List&lt;GrammarTerminalSymbol&gt; getGrammarTerminalSymbols() {
<span class="nc" id="L190">    return grammarTerminalSymbols;</span>
  }

  /**
   * Devuelve el conjunto de símbolos no terminales de la gramática.
   * 
   * @return el conunto de símbolos no terminales de la gramática.
   */
  public List&lt;GrammarNonTerminalSymbol&gt; getGrammarNonTerminalSymbols() {
<span class="fc" id="L199">    return grammarNonTerminalSymbols;</span>
  }

  /**
   * Comprueba que la gramática definida cumple con todas las restricciones
   * definidas o lanzará una GrammarNotValidException
   * 
   * @throws GrammarNotValidException
   *           Lanzada cuando la gramática no pase las validaciones definidas.
   * 
   * @see progen.kernel.grammar.validations
   */
  public void validate() throws GrammarNotValidException {
<span class="fc" id="L212">    new GrammarCheck(this).validate();</span>
<span class="fc" id="L213">  }</span>

  /**
   * Define todas y cada una de las producciones que se especifican en el
   * identificador de function-set pasado por parámetro, indicando si se ha
   * podido llevar la operación a cabo o no.
   * 
   * @param functionSet
   *          identificador de &lt;i&gt;function-set&lt;/i&gt; que definirá el conjunto de
   *          producciones que es necesario crear.
   * @return &lt;code&gt;true&lt;/code&gt; si se crearon todas las producciones definidas en
   *         el &lt;i&gt;function-set&lt;/i&gt; o &lt;code&gt;false&lt;/code&gt; en caso contrario.
   */
  private boolean loadGrammar(int functionSet) {
<span class="fc" id="L227">    String functions[] = ProGenContext.getMandatoryProperty(&quot;progen.functionSet&quot; + functionSet).trim().split(&quot;,[ ]*&quot;);</span>
    Function function;
    Production production;
    GrammarNonTerminalSymbol args[];
    GrammarNonTerminalSymbol left;
    GrammarTerminalSymbol right;
<span class="fc" id="L233">    boolean loadedOK = true;</span>

<span class="pc bpc" id="L235" title="1 of 4 branches missed.">    for (int i = 0; loadedOK &amp;&amp; i &lt; functions.length; i++) {</span>

<span class="fc" id="L237">      function = Function.load(functions[i]);</span>
<span class="fc" id="L238">      left = getGrammarNonTerminalSymbol(function.getReturnType());</span>
<span class="fc" id="L239">      args = getGrammarNonTerminalSymbol(function.getArgsType());</span>
<span class="fc" id="L240">      right = new GrammarTerminalSymbol(function);</span>
<span class="fc" id="L241">      production = new Production(left, right, args);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">      if (!productions.contains(production)) {</span>
<span class="fc" id="L243">        productions.add(production);</span>
<span class="fc" id="L244">        grammarTerminalSymbols.add(right);</span>
      } else {
<span class="nc" id="L246">        loadedOK = false;</span>
      }

    }
<span class="fc" id="L250">    return loadedOK;</span>
  }

  /**
   * Representación en forma de String de la gramática. En este caso, únicamente
   * se representarán las producciones, ya que el resto de elementos que definen
   * la gramática, se pueden obtener de forma inmediata viendo esta información
   * y la nomenclatura seguida.
   */
  public String toString() {
<span class="nc" id="L260">    StringBuffer stb = new StringBuffer();</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">    for (Production production : productions) {</span>
<span class="nc" id="L262">      stb.append(production.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L263">    }</span>
<span class="nc" id="L264">    return stb.toString();</span>
  }

  /**
   * Devuelve el símbolo no terminal que genera un valor de retorno pasado por
   * parámetro. En el caso de que ya exista un no-terminal que genere ese mismo
   * valor de retorno, no se crea uno nuevo y se devuelve el que se haya
   * encontrado. En caso contrario, se crea un nuevo símbolo no terminal y se
   * añade al conjunto de no terminales de la gramática.
   * 
   * @param returnValue
   *          Valor que tendrá que retornar este símbolo no terminal.
   * @return El símbolo no terminal que cumple con la condición de generar ese
   *         valor de retorno.
   */
  private GrammarNonTerminalSymbol getGrammarNonTerminalSymbol(Object returnValue) {
<span class="fc" id="L280">    boolean find = false;</span>
<span class="fc" id="L281">    GrammarNonTerminalSymbol symbol = null;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">    for (GrammarNonTerminalSymbol symbolTemp : grammarNonTerminalSymbols) {</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">      if (!find) {</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (symbolTemp.getValue().compareTo((String) returnValue) == 0) {</span>
<span class="fc" id="L285">          find = true;</span>
<span class="fc" id="L286">          symbol = symbolTemp;</span>
        }
      }
<span class="fc" id="L289">    }</span>

<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    if (!find) {</span>
<span class="nc" id="L292">      symbol = new GrammarNonTerminalSymbol(&quot;R&quot; + (grammarNonTerminalSymbols.size() - 1), (String) returnValue);</span>
<span class="nc" id="L293">      grammarNonTerminalSymbols.add(symbol);</span>
    }

<span class="fc" id="L296">    return symbol;</span>
  }

  /**
   * Devuelve el conjunto de símbolos no terminales que generar los distintos
   * valores de retorno proporcionados como parámetro.
   * 
   * @param returnValue
   *          conjunto de valores de retorno de los que se quiere obtener los
   *          símbolos no terminales de los que se pueden generar.
   * @return Conjunto de símbolos no terminales que generan los distintos
   *         valores de retorno
   */
  private GrammarNonTerminalSymbol[] getGrammarNonTerminalSymbol(Object returnValue[]) {
    GrammarNonTerminalSymbol symbols[];
<span class="fc" id="L311">    symbols = new GrammarNonTerminalSymbol[returnValue.length];</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">    for (int i = 0; i &lt; returnValue.length; i++) {</span>
<span class="fc" id="L313">      symbols[i] = getGrammarNonTerminalSymbol(returnValue[i]);</span>
    }
<span class="fc" id="L315">    return symbols;</span>
  }

  /**
   * Se encarga de generar las reglas para utilizar los posibles argumentos de
   * este ADF en la gramatica que se ha generado.
   * 
   * @param idADF
   *          identificador del ADF.
   */
  private void generateADFProductions(String idADF) {
    GrammarNonTerminalSymbol left;
    GrammarTerminalSymbol right;
    Function function;
    Production production;
<span class="nc" id="L330">    String[] args = ProGenContext.getMandatoryProperty(&quot;progen.&quot; + idADF + &quot;.interface&quot;).split(&quot;\\$\\$&quot;);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">    for (int i = 1; i &lt; args.length; i++) {</span>
<span class="nc" id="L333">      function = new ARG(idADF, args[i].toString(), i - 1);</span>
<span class="nc" id="L334">      left = getGrammarNonTerminalSymbol(function.getReturnType());</span>
<span class="nc" id="L335">      right = new GrammarTerminalSymbol(function);</span>
<span class="nc" id="L336">      production = new Production(left, right, getGrammarNonTerminalSymbol(function.getArgsType()));</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">      if (!productions.contains(production)) {</span>
<span class="nc" id="L338">        productions.add(production);</span>
<span class="nc" id="L339">        grammarTerminalSymbols.add(right);</span>
      }
    }
<span class="nc" id="L342">  }</span>

  /**
   * Método estático que creará las instancias de la gramática que vendrá
   * identifada por el parámetro
   * 
   * @param idTree
   *          Identificador del árbol del que se quiere generar la gramática.
   * @return gramática que generará el árbolo solicitado.
   */
  public static Grammar makeInstance(String idTree) {
<span class="fc" id="L353">    Grammar grammar = null;</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">    if (&quot;on&quot;.equals(ProGenContext.getOptionalProperty(&quot;progen.hgp&quot;, &quot;off&quot;))) {</span>
<span class="nc" id="L355">      grammar = new HGPGrammar(idTree);</span>
    } else {
<span class="fc" id="L357">      grammar = new Grammar(idTree);</span>
    }
<span class="fc" id="L359">    return grammar;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>